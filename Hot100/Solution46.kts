//46. 全排列
//中等
//相关标签
//相关企业
//给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
//
//
//
//示例 1：
//
//输入：nums = [1,2,3]
//输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
//示例 2：
//
//输入：nums = [0,1]
//输出：[[0,1],[1,0]]
//示例 3：
//
//输入：nums = [1]
//输出：[[1]]
//
//
//提示：
//
//1 <= nums.length <= 6
//-10 <= nums[i] <= 10
//nums 中的所有整数 互不相同
fun permute(nums: IntArray): List<List<Int>> {
    if (nums.size == 1) {
        return listOf(nums.toList())
    }
    val perms = mutableListOf<List<Int>>()
    for (i in nums.indices) {
        val current = nums[i]
        val remaining = nums.copyOfRange(0, i) + nums.copyOfRange(i + 1, nums.size)
        val remainingPerms = permute(remaining)
        for (perm in remainingPerms) {
            perms.add(listOf(current) + perm)
        }
    }
    return perms
}

// 输入列表
val list = intArrayOf(1, 2, 3)
// 生成所有排列
val permutations = permute(list)
// 打印每一个排列
for (perm in permutations) {
    println(perm)
}
//好的！我尝试用自然语言和具体的示例来演示这个算法的过程，帮助你更直观地理解它是如何工作的。
//
//---
//
//### 问题描述
//我们需要生成一个列表的所有可能排列。例如，对于列表`[1, 2, 3]`，它的所有排列是：
//```
//[1, 2, 3]
//[1, 3, 2]
//[2, 1, 3]
//[2, 3, 1]
//[3, 1, 2]
//[3, 2, 1]
//```
//
//---
//
//### 算法思路
//1. **固定一个元素**：从列表中选取一个元素作为排列的第一个元素。
//2. **递归生成剩余元素的排列**：对剩余的元素递归调用算法，生成它们的所有排列。
//3. **组合结果**：将固定的元素与每一个剩余元素的排列组合，形成新的排列。
//4. **重复以上步骤**：对列表中的每一个元素都执行上述操作。
//
//---
//
//### 示例演示
//以列表`[1, 2, 3]`为例，我们一步步演示算法的执行过程。
//
//#### 第一步：固定`1`，处理剩余元素`[2, 3]`
//1. **固定`1`**，剩余元素是`[2, 3]`。
//2. **递归处理`[2, 3]`**：
//   - 固定`2`，剩余元素是`[3]`，排列是`[2, 3]`。
//   - 固定`3`，剩余元素是`[2]`，排列是`[3, 2]`。
//3. **组合结果**：
//   - `1` + `[2, 3]` = `[1, 2, 3]`
//   - `1` + `[3, 2]` = `[1, 3, 2]`
//
//#### 第二步：固定`2`，处理剩余元素`[1, 3]`
//1. **固定`2`**，剩余元素是`[1, 3]`。
//2. **递归处理`[1, 3]`**：
//   - 固定`1`，剩余元素是`[3]`，排列是`[1, 3]`。
//   - 固定`3`，剩余元素是`[1]`，排列是`[3, 1]`。
//3. **组合结果**：
//   - `2` + `[1, 3]` = `[2, 1, 3]`
//   - `2` + `[3, 1]` = `[2, 3, 1]`
//
//#### 第三步：固定`3`，处理剩余元素`[1, 2]`
//1. **固定`3`**，剩余元素是`[1, 2]`。
//2. **递归处理`[1, 2]`**：
//   - 固定`1`，剩余元素是`[2]`，排列是`[1, 2]`。
//   - 固定`2`，剩余元素是`[1]`，排列是`[2, 1]`。
//3. **组合结果**：
//   - `3` + `[1, 2]` = `[3, 1, 2]`
//   - `3` + `[2, 1]` = `[3, 2, 1]`
//
//---
//
//### 最终结果
//通过以上步骤，我们得到了列表`[1, 2, 3]`的所有排列：
//```
//[1, 2, 3]
//[1, 3, 2]
//[2, 1, 3]
//[2, 3, 1]
//[3, 1, 2]
//[3, 2, 1]
//```
//
//---
//
//### 递归调用树
//为了更清晰地理解递归过程，我们可以用树状图表示每一步的递归调用：
//
//```
//固定1
//├── 固定2
//│   └── 固定3 → [1, 2, 3]
//└── 固定3
//    └── 固定2 → [1, 3, 2]
//
//固定2
//├── 固定1
//│   └── 固定3 → [2, 1, 3]
//└── 固定3
//    └── 固定1 → [2, 3, 1]
//
//固定3
//├── 固定1
//│   └── 固定2 → [3, 1, 2]
//└── 固定2
//    └── 固定1 → [3, 2, 1]
//```
//
//---
//
//### 总结
//这个算法的核心思想是：
//1. **固定一个元素**，作为排列的第一个元素。
//2. **递归处理剩余元素**，生成它们的所有排列。
//3. **组合结果**，将固定的元素与每一个剩余排列组合。
//4. **重复上述步骤**，对列表中的每一个元素都执行一遍。
//
//通过这种分而治之的方式，我们可以系统地生成所有可能的排列。希望这个自然语言和示例的演示能帮助你更好地理解算法的执行过程！